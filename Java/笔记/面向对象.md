# 面向对象
---

## 一.面向对象和面向过程的区别

两者主要是解决问题的方式不同

-   **面向过程**是把问题拆解为一个个子问题来解决
-   **面向对象**是先抽象出对象，然后通过对象执行方法的方式来解决

面向对象编程一般比面向过程编程更容易维护

下面是一个求圆的面积和周长的示例，简单分别展示了面向对象和面向过程两种不同的解决方案：

**面向对象**

```java
//定义对象
public class Circle{
    private double radius;//定义圆的半径属性

    public Circle(double radius){
        this.radius=radius;
    }

    //计算面积
    public double getArea(){
        return Math.PI*radius*radius;
    }

    //计算周长
    public double getPerimet(){
        return Math.PI*radius*2;
    }
}
```

**面向过程**

```java
public class Main {
    public static void main(String[] args) {
        // 定义圆的半径
        double radius = 3.0;

        // 计算圆的面积和周长
        double area = Math.PI * radius * radius;
        double perimeter = 2 * Math.PI * radius;

        // 输出圆的面积和周长
        System.out.println("圆的面积为：" + area);
        System.out.println("圆的周长为：" + perimeter);
    }
}
```

**可以看出来面向过程编程是需要什么变量就定义什么变量，不便于维护**

## 二. 对象的创建

**1. 创建方法**

通过**new** 运算符或者通过**对象引用**的方式来创建对象

- **new**创建一个对象实例是在堆内存上创建一个新的新的对象实例
- **对象引用**创建对象是通过将新创建的对象指向已有的对象实例

**2. 什么是对象引用**

当将一个引用变量赋值给另一个变量时，复制的是引用（内存地址），而不是对象本身。这意味着两个引用变量现在指向同一个对象。

**一个对象引用可以指向一个对象，但是一个对象可以有多个对象引用指向它**

```java
//这个obj是一个对象引用，指向一个通过new关键字创建的对象实例
MyClass obj = new MyClass();

//这里通过obj这个对象引用来创建一个对象
MyClass anotherObj = obj;
```

这里我们分别用new关键字和对象引用的方法来实例化对象，**这两个对象引用都指向了同一个对象。**

**3.对象相等和对象引用相等的区别**

- **对象相等**比较的是内存中存放的内容是否相等
- **引用相等**比较的是他们指向的内存地址(对象实例的地址)是否相等

**举个例子**
```java
String str1 = "hello";
String str2 = new String("hello");
String str3 = "hello";
// 使用 == 比较字符串的引用相等
System.out.println(str1 == str2);
System.out.println(str1 == str3);
// 使用 equals 方法比较字符串的相等
System.out.println(str1.equals(str2));
System.out.println(str1.equals(str3));

```

**输出结果：**

```
false
true
true
true
```

**'=='** 是用来比较两个对象引用的**地址是否相等**
**equals** 方法是比较两个对象引用指向的对象存的**内容是否相等**

从上面的代码输出结果可以看出：
- str1 和 str2 不相等，而 str1 和 str3 相等。这是因为 == 运算符比较的是字符串的引用是否相等。
- str1、 str2、str3 三者的内容都相等。这是因为equals 方法比较的是字符串的内容，即使这些字符串的对象引用不同，只要它们的内容相等，就认为它们是相等的

**4. 构造方法**

**什么是构造方法**

构造方法（Constructor）是一种特殊的方法，其主要用途是在创建对象时初始化该对象，即为对象成员变量赋初值，它通常与类同名，并且没有返回类型，也不能返回任何值。构造方法可以有参数，用以通过提供的参数来初始化对象属性。

>我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。

**例子**
```java
public class MyClass {
    private int value;

    // 构造方法
    public MyClass(int initialValue) {
        value = initialValue;
    }
}
```

**如果一个类没有构造方法还能正确执行吗？**

如果一个类没有显式地定义构造方法，Java 编译器会为这个类提供一个默认的无参构造方法（也称为默认构造器）。这个默认的构造方法没有参数，并且其方法体为空，它主要的作用是执行对象的创建和成员变量的初始化（如果有初始值的话）。

```java
public class MyClass {
    // 无显式定义的构造方法
}

// 在其他
```

**构造方法有哪些特点**
构造方法特点如下：名字与类名相同。没有返回值，但不能用 void 声明构造函数。
- 生成类的对象时自动执行，无需调用。
- 构造方法不能被 override（重写）,但是可以 overload（重载）,**可以看到一个类中有多个构造函数的情况。**


## 三. 面向对象的三大特征

### 1.封装

封装指的是将对象的内部属性封装到对象内部,让外界无法访问只能通过对象的方法来访问对象的属性

比如电视机，我们无法直接从他的外观来获取他的内部参数，但是我们可以通过遥控器来操控电视。

```java
public class Student {
    private int id;//id属性私有化
    private String name;//name属性私有化

    //获取id的方法
    public int getId() {
        return id;
    }

    //设置id的方法
    public void setId(int id) {
        this.id = id;
    }

    //获取name的方法
    public String getName() {
        return name;
    }

    //设置name的方法
    public void setName(String name) {
        this.name = name;
    }
}
```


### 2.继承

不同的对象之间会存在类似的属性，比如大学生，小学生，高中生都是学生，他们都共享学生的属性，**他们就是继承了学生类的特点**，但是又多了一些独属于自己的属性

**继承的特点**

- 子类拥有父类对象所有的属性和方法(包括私有属性和方法),但是父类的私有方法和属性，子类只能拥有而不能访问

- 子类可以拥有自己独有的属性(父类没有的属性)，而不能选择性继承父类的属性

- 子类可以用自己的方式实现父类的方法(方法重写)


### 3.多态

多态的意思是一个对象有多种状态，具体表现为**父类的引用指向子类的实例**

#### **多态的特点**

- 对象类型和引用类型之间具有继承(类)/实现(接口)的关系
- 引用类型变量发出的方法到底调用的是哪个类中的方法，必须在程序运行期间才能确定
- 多态不能调用"只在子类存在但在父类中不存在的方法"
- 如果子类重写了父类的方法，真正执行的是子类覆盖的方法

#### **为什么多态有这些特点**
    多态的这些特点是由Java的编译与运行特点决定的

**1.静态绑定（也称为早期绑定或编译时绑定）**

在编译期间完成，而不是运行时。
Java中的静态方法、私有方法、final方法和构造函数都是通过静态绑定处理的，因为这些方法不能被重写，所以它们不需要在运行时确定。

**2.动态绑定（也称为晚期绑定或运行时绑定）**

在运行时根据对象的实际类型决定要调用的方法。
涉及到虚方法，即可以在子类中被重写的方法。
继承中的方法绑定
当一个子类对象通过父类类型的引用调用一个方法时：

- **如果该方法在父类中被声明为final、static或private(非虚函数)**，则使用静态绑定，因为这些方法不可被重写，所以可以在编译时确定。
- **如果方法可以被重写(即不是final、static或private)**，则会使用动态绑定。这意味着JVM会在运行时查看对象的实际类型，并调用那个类型上适当的方法版本，即使该调用是通过父类类型的引用进行的。

**总结来说**

- 编译期决定了这个引用**能调用的方法-重载方法**
- 运行期决定了这个引用**调用方法的版本-重写方法**

**举个逆天的例子**
```java
public class A {  
    public String show(D obj) {  
        return ("A and D");  
    }  
  
    public String show(A obj) {  
        return ("A and A");  
    }   
  
}  
//这里的B是A的子类
public class B extends A{  
    public String show(B obj){  
        return ("B and B");  
    }  
      
    public String show(A obj){  
        return ("B and A");  
    }   
}  
//这个C是B的子类,由于B是A的子类,这个C也是A的一个间接子类
public class C extends B{  
  
}  
//这个D是B的子类,由于B是A的子类,这个D也是A的一个间接子类
public class D extends B{  
  
}  
  
public class Test {  
    public static void main(String[] args) {  
        A a1 = new A();  //通过new关键字来创建一个对象实例,a1这个对象引用指向创建的对象A实例
        A a2 = new B();  //通过new关键字来创建一个对象实例,a1这个对象引用指向创建的对象B实例
        B b = new B();  
        C c = new C();  
        D d = new D();  
        
        System.out.println("1--" + a1.show(b));  
        System.out.println("2--" + a1.show(c));  
        System.out.println("3--" + a1.show(d));  
        System.out.println("4--" + a2.show(b));  
        System.out.println("5--" + a2.show(c));  
        System.out.println("6--" + a2.show(d));  
        System.out.println("7--" + b.show(b));  
        System.out.println("8--" + b.show(c));  
        System.out.println("9--" + b.show(d));        
    }  
}                 
```

**分析**

**System.out.println("5--" + a2.show(c));**

- **编译(静态绑定)**

    在静态编译期,编译器根据a1的类型将a1绑定到A类,然后决定a1能调用的方法
    ```java
    public class A {  
    public String show(D obj) {  
        return ("A and D");  
    }  
  
    public String show(A obj) {  
        return ("A and A");  
    }   
  }
    ```
- **运行(动态绑定)**
    
    在程序运行之后决定a2到底调用哪个方法,**决定调用方法的版本,即是否发生了重写**

    ```java
    //这里的B是A的子类
        public class B extends A{  
    public String show(B obj){  
        return ("B and B");  
    }  
      
    public String show(A obj){  
        return ("B and A");  
    }   
    }
    ```
   - 在静态绑定的时候决定**a2能调用show(A obj),show(D obj),方法**

   - 在实例化的时候又决定了a2指向的是A的子类B, **在子类B中对show(A obj)方法进行了重写**, 于是a1实际执行show(A obj)的时候调用的是B类重写后的方法

    - 同时由于静态编译的时候已经决定了a2绑定到了A类,所以 **动态绑定的B类中的show(B obj)方法是无法被调用的**

- **结果分析:a2.show(c)**
    由于c是A的一个间接子类,于是选择使用子类重写的方法show(A obj)

    最后输出**B and A**

#### **什么是虚函数**

虚函数的存在是为了**实现重写**，Java中的普通方法其实就是**cpp中的虚函数**

动态绑定是Java的默认行为，如果Java中不希望某个函数具有虚函数的特性，就可以给这个方法加上final关键字 **(非虚函数不允许被重写)**

#### **什么是super关键字**

继承于父类的子类如果对父类中的方法进行了重写，由于Java的动态绑定特性子类将**无法直接调用父类中的原方法**

由于Java在编译期间有着静态绑定的特性，通过多态的方法创建的子类**能够访问父类的方法**

在Java中，当创建一个子类实例并希望调用继承自父类的方法时，通常有几种不同的情景和相应的方法可以实现这一需求。这包括直接调用、通过 super 关键字调用，以及在方法重写的情况下调用父类的方法。下面详细解释每种情况。

**1. 直接调用父类的方法**

如果子类没有重写父类的方法，子类实例可以直接调用继承自父类的方法。这是最直接的情况，无需任何特殊语法。

```java
class Parent {
    void display() {
        System.out.println("This is the Parent class method.");
    }
}

class Child extends Parent {
    // 没有重写display方法
}

public class Test {
    public static void main(String[] args) {
        Child obj = new Child();
        obj.display();  // 直接调用继承自Parent类的display方法
    }
}

```

**2. 通过 super 关键字调用父类的方法**
如果子类重写了父类的方法但在子类的方法实现中仍需要调用父类的方法，可以使用 super 关键字来实现。这种情况常见于需要扩展而不是完全替代父类功能的场景。

```java
class Parent {
    void display() {
        System.out.println("This is the Parent class method.");
    }
}

class Child extends Parent {
    @Override
    void display() {
        super.display();  // 调用父类的display方法
        System.out.println("This is the Child class method.");
    }
}

public class Test {
    public static void main(String[] args) {
        Child obj = new Child();
        obj.display();  // 首先调用父类的方法，然后继续执行子类的方法
    }
}
```

#### **什么是final关键字**

在Java中，final 关键字是一个非常重要的修饰符，它可以用于修饰类、方法和变量。final 关键字的主要目的是阻止变更。具体来说，当final修饰一个实体时，这个实体就不能被进一步改变。在编译期间有final关键字修饰的变量的类型就已经被**确定了**

这里是如何使用final关键字的详细说明：

**1. final 修饰变量**
当final修饰一个变量时，这个变量就成为了常量，意味着它的值一旦被初始化之后不能被改变。这适用于成员变量、局部变量以及参数变量。

- 局部变量：当final修饰局部变量时，一旦给局部变量赋值后，其值就不能更改。
- 成员变量：必须在字段声明时、在构造器中或初始化块中初始化final成员变量。
- 参数变量：将参数标记为final表示你不希望函数内部改变输入参数的值。

```java
final int x = 100;
x = 200; // 编译错误，不能修改一个final变量的值

class Test {
    final int instanceVar; // 成员变量

    public Test() {
        instanceVar = 123; // 必须在构造器中初始化
    }

    void foo(final int y) {
        // y = 10; // 编译错误，不能修改final参数
    }
}
```

**2. final 修饰方法**

当final修饰一个方法时，这个方法不能被子类重写。但是，子类依然可以继承该方法，只是不能修改它的实现。这通常用来防止关键功能的更改，确保方法的行为不会被任何继承的类修改。

```java
class Parent {
    final void show() {
        System.out.println("这个方法不能被重写");
    }
}

class Child extends Parent {
    // void show() { // 编译错误，不能重写final方法
    //     System.out.println("尝试重写");
    // }
}
```

**3. final 修饰类**

当final修饰一个类时，表明这个类不能被继承。换句话说，没有类可以继承一个被声明为final的类。这通常用于保证类的安全，防止外部继承并修改其行为，例如不允许修改某些关键算法的实现。

```java
final class CannotBeExtended {
    void display() {
        System.out.println("这个类不能被继承");
    }
}

// class TryExtend extends CannotBeExtended { // 编译错误，不能继承final类
//     void display() {
//         System.out.println("尝试继承");
//     }
// }
```
#### **父类引用创建的子类实例和子类引用创建的子类实例有什么区**

两者的区别在于能否**调用子类中存在而父类中不存在的方法**，这个区别是由Java语言静态绑定的特点决定

**父类引用创建的子类实例**

这种情况通常用于展示多态的特性。多态允许一个父类引用指向一个子类对象，允许你在运行时决定具体执行哪个类的方法。这种方法特别有用于实现代码的通用性和灵活性。

```java
class Parent {
    void display() {
        System.out.println("Parent display");
    }
}

class Child extends Parent {
    @Override
    void display() {
        System.out.println("Child display");
    }

    void specificMethod() {
        System.out.println("Specific method of Child");
    }
}

public class Test {
    public static void main(String[] args) {
        Parent obj = new Child();
        obj.display();  // 调用 Child 类的 display 方法
        // obj.specificMethod();  // 编译错误: Parent 类型的引用不能调用 specificMethod
    }
}

```

**子类引用创建的子类实例**

使用子类引用创建的子类实例不涉及多态，但提供了对子类特有方法和成员的直接访问。

```java
Child obj = new Child();
obj.display();  // 调用 Child 类的 display 方法
obj.specificMethod();  // 正确: 调用 Child 类的 specificMethod 方法

```



#### **多态的实现方法**

1. **[重写](./方法.md)**
2. **[接口](./接口.md)**
3. **[抽象类和抽象方法](./抽象类与抽象方法.md)**