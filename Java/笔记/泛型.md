# 泛型

**Java 泛型（Generics）** 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。

>  编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 ArrayList<Person> persons = new ArrayList<Person>() 这行代码就指明了该 ArrayList 对象只能传入 Person 对象，如果传入其他类型的对象就会报错。

---

## 1.泛型的使用方式

### 1.1泛型类

泛型类是指带有一个或多个类型参数的类。类型参数在类定义时指定，可以在类的实例化时确定具体的类型。

**示例**
```java
//定义
public class Box<T> {
    private T content;

    public void setContent(T content) {
        this.content = content;
    }

    public T getContent() {
        return content;
    }
}
//使用
Box<String> stringBox = new Box<>();
stringBox.setContent("Hello");
String content = stringBox.getContent();
```

### 1.2泛型接口

泛型接口是指带有类型参数的接口。类型参数在接口定义时指定，可以在实现接口时确定具体的类型。

```java
//定义泛型接口
public interface Comparable<T> {
    int compareTo(T o);
}
//实现泛型接口
public class MyComparableClass implements Comparable<MyComparableClass> {
    private int value;

    public MyComparableClass(int value) {
        this.value = value;
    }

    @Override
    public int compareTo(MyComparableClass o) {
        return Integer.compare(this.value, o.value);
    }
}
```

### 1.3泛型方法

泛型方法是指带有类型参数的方法。类型参数在方法定义时指定，可以在方法调用时确定具体的类型。

```java
//定义泛型方法
public <T> void printArray(T[] array) {
    for (T element : array) {
        System.out.print(element + " ");
    }
    System.out.println();
}
//使用泛型方法
Integer[] intArray = {1, 2, 3, 4, 5};
String[] strArray = {"A", "B", "C", "D"};

printArray(intArray);
printArray(strArray);
```

**静态泛型方法**
```java
//静态泛型方法
public static < E > void printArray( E[] inputArray )
```
>注意:  一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <E>

### 1.4有界类型参数
泛型可以指定类型参数的上界或下界，以限制类型参数的范围。

**上界**：使用extends关键字。
**下界**：使用super关键字。
- **无界通配符**：<?>
- **有界通配符(上界)**：<? extends T>
- **有界通配符(下界)**：<? super T>
```java
// 上界：T 必须是 Number 的子类
public <T extends Number> void printNumber(T number) {
    System.out.println(number);
}

// 下界：T 必须是 Integer 的父类
public void addToList(List<? super Integer> list) {
    list.add(1);
}
```

## 2.类型擦除

在Java中，泛型不能直接使用**原始类型（如 int, char, double 等）**，只能使用**包装类型（如 Integer, Character, Double 等）**。这是因为Java泛型是通过类型擦除来实现的，而原始类型在类型擦除后无法与对象类型兼容。

Java中的泛型在编译期间会进行类型擦除，这意味着所有泛型类型参数都会被替换为它们的**非泛型上界（通常是 Object）**。由于原始类型（例如 int）不是对象类型，它们不能作为泛型参数传递。

**示例**
假设我们有一个简单的泛型类 Box：

```java
//定义泛型类
public class Box<T> {
    private T content;

    public void setContent(T content) {
        this.content = content;
    }

    public T getContent() {
        return content;
    }
}

//使用泛型类的时候只能使用包装类型的对象
Box<Integer> integerBox = new Box<>();
integerBox.setContent(123); // 自动装箱，将 int 转换为 Integer
int content = integerBox.getContent(); // 自动拆箱，将 Integer 转换为 int
System.out.println("Box Content: " + content);

```