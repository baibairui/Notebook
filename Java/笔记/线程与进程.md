# 进程

## 基本概念

**一. 什么是进程**

进程是程序的一次执行过程，是系统运行程序的基本单位。
进程是动态的，系统运行程序的过程就是一个进程的创建，运行到销毁的过程

在java中启动一次main函数其实就是启动了一个JVM进程，而main函数所在的线程就是这个JVM进程中的一个线程，也被称为程序的主线程

**二. 什么是线程**

线程是比进程更小的一个执行过程。在一个进程的启动过程中可以启动多个子线程

一个java程序的运行其实就是一个JVM进程启动了多个子线程


**三. 什么是并发**

并发指的是多个任务被同一个CPU在同一个时间段内处理，但每一个瞬间时刻只有一个任务被这个CPU处理

**四. 什么是并行**

并行指的是多个CPU在同一个时刻处理多个任务,每一个瞬间都有着多个任务在被处理

**五. 并发与并行的区别**

- 并发：两个及两个以上的作业在同一 时间段 内执行。<br>
- 并行：两个及两个以上的作业在同一 时刻 执行。<br>

**最关键的点**
是否是多个任务是否同时执行
## **Java与并发编程**

### **一.创建线程的方法**

#### **1.java中最基础的实现并发的方法就是使用Thread类**


````java
// 继承Thread类来实现多线程
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread running");
    }
}

// 实现Runnable接口来实现多线程
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable running");
    }
}

public class ConcurrencyTest {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();

        Thread t2 = new Thread(new MyRunnable());
        t2.start();
    }
}

````

#### **2. 实现Runnable接口来实现多线程**

因为java中只允许单继承(即一个类只能extends 一个父类)，所以对于已经继承父类的类可以进行实现Runnable接口来实现

因为实现Runnable类的方法实现的多线程没有start（）方法，所以我们是通过创建一个新的Thread类并传递实现runnable类的方法来创建新的线程。

```java
// 实现Runnable接口来实现多线程
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable running");
    }
}

public class ConcurrencyTest {
    public static void main(String[] args) {
        MyRunnable r1=new MyRunnable();

        //通过向Thread的构造器传入实现了Runnable接口的类实例来创建线程
        Thread t2 = new Thread(new MyRunnable());
        t2.start();

        //通过向Thread的构造器传入实例
        Thread t3=new Thread(r1);
        t3.start();

        //通过匿名内部类的方法实现Runnable接口创建线程
        Thread t4=new Thread(new Runnable(){
            @Override
            public void run(){
                System.out.println("Runnable running");
            }
        });

        //通过匿名内部类的方法实现Thread
        Thread t5=new Thread(){
            public void run(){
                System.out.println("Runnable running");
            }
        };
    }
}
```

**实现Runnable接口方法和extend Thread方法的区别**
- 从java的设计来看，从Thread继承和实现Runnable接口没有本质区别，因为Thread类本身就实现了Runnable接口
- 实现Runnable接口的方式更适合多个线程共享一个资源的情况，避免了单继承的限制

#### 3. 实现Callable接口

**"Callable"** 是Java并发库中的一个接口，与**Runnable**接口类似需要通过**重写run()方法**来创建线程。**Callable接口**需要重写**call()**方法来创建线程

**注意Thread类的构造器只可以传入实现了Runnable接口的对象,因此通常是通过方法类ExecutorService来使用实现Callable接口的对象**


>**使用 Callable 创建线程的一般步骤如下：**
**1.实现 Callable 接口**：实现 Callable 接口并定义 call() 方法。
**2.使用 ExecutorService 提交任务**：使用 ExecutorService 提交 Callable 任务。
**3.获取任务结果**：通过 Future 对象获取任务结果。

**示例代码**
```java
public class test{
    public static void main(String[] args){
        ExecutorService eS=ExecutorService.newFixedThreadPool(2);
        Future<String> future=eS.submit(new Callable<String>() {
            @Override
            public String call() throws Exception{
                Thread.sleep(5000);//模拟线程休眠
                return "work done";
            }
        });
        try{
            String res=future.get();
            System.out.println("Result from Callable: " + res);
        }catch(Exception e){
            e.printStackTrace();
        }
        eS.shutdown();
    }
    
}
```

### **二.如何启动线程**

**1. start()方法**

start()方法用于启动一个新的线程。当你调用一个线程的start()方法时，Java虚拟机调用该线程的run()方法在新启动的线程中执行。这意味着，调用start()会导致操作系统底层创建一个新的线程，然后在这个新线程中并行地执行run()方法。使用start()可以使得多个线程并发执行，从而提高程序的效率。
````java
class MyThread extends Thread {
    public void run() {
        System.out.println("Running in a new thread");
    }
}

public class ThreadExample {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();  // 新线程中执行run()方法
        System.out.println("Running in main thread");
    }
}
````
**2. run()方法**

run()方法只是一个普通的方法调用，如果直接从主线程或任何线程调用run()，它将作为一个普通方法在当前线程中执行，而不会创建新的线程。这样做不会实现多线程的并发执行，而是在同一个线程中顺序执行。
````java
class MyThread extends Thread {
    public void run() {
        System.out.println("Running in the same thread");
    }
}

public class ThreadExample {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.run();  // 在当前线程（这里是主线程）中执行run()方法
        System.out.println("Running in main thread");
    }
}
````


### **三.Java中线程类的状态**

**Java中的Thread.State是一个枚举类**，它定义了线程的六种状态
```java
public enum Thread.State {
  
/**
     * Thread state for a thread which has not yet started.
     */
    NEW,

    /**
     * Thread state for 

    RUNNABLE,

    /**
     * Thread state for a thread blocked waiting for a monitor lock. A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling Object.wait.
     */
    BLOCKED,

    /**
     * Thread state for a waiting thread. A thread is in the waiting state due to calling one of the following methods:
     * <ul>
     * <li>{@link Object#wait() Object.wait} with no timeout</li>
     * <li>{@link #join() Thread.join} with no timeout</li>
     * <li>{@link LockSupport#park() LockSupport.park}</li>
     * </ul>
     */
    WAITING,

    /**
     * Thread state for a waiting thread with a specified w
@link Thread#sleep Thread.sleep}</li>
     * <li>{@link Object#wait(long) Object.wait} with timeout</li>
     * <li>{@link #join(long) Thread.join} with timeout</li>
     * <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
     * <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
     * </ul>
     */
    TIMED_WAITING,

    /**
     * Thread state for a ter

    TERMINATED;
}
```

![alt text](image-25.png)


**1.NEW**

当一个线程对象被创建但尚未调用 start() 方法时，线程处于 NEW 状态。

```java
Thread thread = new Thread(() -> System.out.println("Thread is running"));
System.out.println(thread.getState()); // 输出 NEW
```

**2. RUNNABLE**

当调用 start() 方法后，线程处于 RUNNABLE 状态。线程可能正在运行，也可能等待 CPU 时间片。

```java
Thread thread = new Thread(() -> {
    while (true) {
        // 无限循环，保持线程在 RUNNABLE 状态
    }
});
thread.start();
System.out.println(thread.getState()); // 输出 RUNNABLE
```

**3.BLOCKED**

当线程试图进入一个被其他线程持有的同步块(锁被其他线程持有)时，它进入 BLOCKED 状态。

```java
public class BlockedExample {
    public static void main(String[] args) throws InterruptedException {
        final Object lock = new Object();

        Thread t1 = new Thread(() -> {
            synchronized (lock) {
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (lock) {
                System.out.println("Thread 2 acquired the lock");
            }
        });

        t1.start();
        Thread.sleep(1000); // 确保t1先获取到锁
        t2.start();

        Thread.sleep(1000); // 确保t2进入BLOCKED状态
        System.out.println(t2.getState()); // 输出 BLOCKED
    }
}
```

**4.WAITING**

当线程无限期等待另一个线程唤醒时，它进入 WAITING 状态。

```java
public class WaitingExample {
    public static void main(String[] args) throws InterruptedException {
        final Object lock = new Object();

        Thread t1 = new Thread(() -> {
            synchronized (lock) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        t1.start();
        Thread.sleep(1000); // 确保t1调用wait()
        System.out.println(t1.getState()); // 输出 WAITING
    }
}
```
**5. TIMED_WAITING**

当线程等待另一个线程唤醒或者等待指定时间时，它进入 TIMED_WAITING 状态。

```java
public class TimedWaitingExample {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        t1.start();
        Thread.sleep(1000); // 确保t1调用sleep()
        System.out.println(t1.getState()); // 输出 TIMED_WAITING
    }
}
```

**6. TERMINATED**

当线程完成执行或者由于异常退出时，它进入 TERMINATED 状态

```java
public class TerminatedExample {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            System.out.println("Thread is running");
        });

        t1.start();
        t1.join(); // 等待线程t1结束
        System.out.println(t1.getState()); // 输出 TERMINATED
    }
}
```