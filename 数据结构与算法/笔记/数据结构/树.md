# 树
---

## **1.二叉树**
 **为什么要有二叉树**
   二叉树是一种重要的数据结构，用于优化特定类型的数据操作，尤其是搜索、插入和删除。以下是链表、数组与二叉树的比较，来展示为什么二叉树在某些场景下更有优势：

- **链表：**

**优点：** 链表占用的内存空间较小，且可以灵活地进行节点的增加和删除。
**缺点：** 不能通过下标直接访问元素，查找元素的时间复杂度为 O(n)。
- **数组：**

**优点：** 可以通过下标直接访问元素，查找元素的时间复杂度为 O(1)。
**缺点：** 需要在内存中开辟连续的空间，大小固定，对动态数据集的处理较为低效。

对于 普通单链表 来说，由于查找数据的时间复杂度是 O(n)，在数据集较大时效率较低。而数组虽然支持快速随机访问，但其静态结构和连续空间要求限制了其在处理大量动态操作时的效率。

为了结合链表的动态特性和数组的快速访问优点，设计了二叉树结构。二叉树通过树状的数据结构，使得数据元素以层次关系进行存储，从而允许数据在保持一定顺序的同时，也能快速地进行插入和删除操作。在二叉树中：

一个 完全二叉树 可以将查找的**最优时间复杂度优化到 O(log n)。**
二叉树结构使得数据可以在插入和删除时动态地调整，不需要像数组那样进行大量的数据移动。

二叉树在很多情况下提供了更好的性能，尤其是对于需要频繁插入和删除的动态数据集。

**普通二叉树的缺点**
    不能保证插入数据的顺序，即不能保证查找的最优时间复杂度

## **2.二叉搜索树**
**[详情请看博客](https://blog.csdn.net/bairui6666/article/details/135138741?spm=1001.2014.3001.5501)**

**二叉搜索树(BST Tree)** 是对普通二叉树的一种优化，二叉搜索树保证将比**父节点小的节点放在左子树，父节点大的节点放在右子树**

二叉搜索树（BST，Binary Search Tree）是普通二叉树的一个扩展，优化了数据的组织和访问方式。二叉搜索树的特点在于，它为每个节点定义了一个具体的排序方式，这有助于快速检索数据。下面是二叉搜索树的主要特征和优点：

**特征**
节点排序：在二叉搜索树中，每个节点包含一个键及其关联的值。若某个节点有左子树，则左子树上所有节点的键都小于该节点的键；若有右子树，右子树上所有节点的键都大于该节点的键。
数据结构属性：这种属性使得二叉搜索树对于支持动态数据集合的操作（如查找、插入、删除）非常有效。每次操作的平均时间复杂度能够保持在 O(log n)，但这取决于树的高度。
**优点**
- **高效的查找操作：** 可以在logn时间内查找到任何元素，这比未排序的链表或数组快得多。
- **有序性：** 通过中序遍历（左根右）二叉搜索树，可以获得有序的数据序列，这对很多需要排序数据的应用非常有用。
- **灵活的插入和删除：** 添加和移除元素相对于数组来说更为灵活，因为不需要移动其他元素来维持数据结构的连续性。
- **动态数据集：** 非常适合经常变化的数据集，如数据库索引和交互式应用中的数据集。

**缺点**
在极端的情况下BST会退化成一个单链表导致时间复杂度变成O(n)

- **有序数据的连续插入：**
当连续插入的数据是有序的（例如，持续插入递增或递减的数据集），二叉搜索树的每个新节点总是只被添加到树的最右侧或最左侧。这样的插入模式使得树变得非常不平衡，具体表现为每个节点都只有一个子节点（左子节点或右子节点），而另一侧始终为空。

- **递增顺序插入：** 如果我们持续插入递增的数据，每个新节点都将成为前一个节点的右子节点。

- **递减顺序插入：** 如果我们持续插入递减的数据，每个新节点都将成为前一个节点的左子节点。

- **删除操作导致不平衡：**
删除操作同样可以导致BST退化为单链表，尤其是当删除某些关键节点（如具有两个子节点的节点）后，若调整不当，也可能导致树结构单一化。

在二叉搜索树退化为单链表的情况下，它的操作效率将大幅下降。原本对于平衡二叉搜索树的查找、插入和删除操作的时间复杂度是 𝑂(log𝑛)，但在单链表状的BST中，这些操作的时间复杂度会退化到 𝑂(𝑛)这意味着与线性数据结构如链表无异，且失去了使用树结构的优势。

## **3.AVL树**

AVL树为了解决二叉搜索树退化成单链表的情况

AVL树是一种自平衡的二叉搜索树，其名称来自于其发明者 G. M. Adelson-Velsky 和 E. M. Landis。AVL树在二叉搜索树（BST）的基础上增加了一种自动平衡机制，其主要目的是防止BST在极端情况下退化成单链表，从而保证树的操作效率。

**自平衡特性**
AVL树的核心特性是其每个节点的平衡因子（balance factor）都被严格控制在-1, 0或1之间。这个平衡因子是定义为该节点的左子树高度与右子树高度之差。这种平衡保证了在最坏情况下，树的高度保持在 
𝑂(log𝑛)其中 𝑛是树中节点的数量。

**平衡操作**
为了维持这种平衡状态，AVL树在执行插入或删除操作后可能会进行以下几种类型的旋转来重新平衡树：

- **单右旋转（LL旋转）**
当一个节点的左子节点的左子树添加了一个新节点，导致这个节点的平衡因子变为-2时，进行单右旋转。
- **单左旋转（RR旋转）**
当一个节点的右子节点的右子树添加了一个新节点，导致这个节点的平衡因子变为2时，进行单左旋转。
- **左右双旋转（LR旋转）**
当一个节点的左子节点的右子树添加了一个新节点，先对这个左子节点进行单左旋转，然后对原节点进行单右旋转。
- **右左双旋转（RL旋转）**
当一个节点的右子节点的左子树添加了一个新节点，先对这个右子节点进行单右旋转，然后对原节点进行单左旋转。

**优点**
AVL树通过这些旋转确保了树的高度最大为 log𝑛（向下取整），这样的高度保证了查找、插入和删除操作都可以在对数时间内完成，从而大幅提升效率。

**应用**
由于其高效的平衡机制，AVL树非常适合用于需要频繁进行查找、插入和删除操作的场合，如数据库和内存中的查找表。然而，AVL树的维护成本相对较高，尤其是在频繁更新的环境中，因为每次插入或删除都可能需要进行一次或多次旋转。


## **4.红黑树**

红黑树是一种自平衡的二叉搜索树，用于在动态数据集上提供高效的查找、插入和删除操作。它通过特定的规则和调整操作，保持了良好的平衡，而不需要像AVL树那样频繁地进行重平衡。以下是红黑树的核心知识点总结：

### 定义和性质

红黑树保持了以下五个核心性质，以确保树的平衡和操作效率：

1. **节点颜色**：每个节点都被涂成红色或黑色。
2. **根节点**：根节点总是黑色。
3. **红节点规则**：如果一个节点是红色，那么它的两个子节点都必须是黑色。
4. **黑高规则**：从任一节点到其每个叶子的所有简单路径上包含相同数量的黑色节点。
5. **叶子节点**：所有叶子节点（NIL节点）都是黑色。

### 关键操作

红黑树的操作主要涉及调整树的结构以保持或恢复上述性质，主要操作包括：

- **插入**：插入可能会引入红色冲突，需通过旋转和重新着色来解决。
- **删除**：删除节点后可能会破坏红黑树的性质，需要复杂的调整过程，包括旋转和重新着色。
- **查找**：与普通的二叉搜索树类似，查找的时间复杂度为 \(O(\log n)\)。

### 调整旋转

调整旋转包括：

- **左旋转**：将节点向左旋转，以减小右侧的深度。
- **右旋转**：将节点向右旋转，以减小左侧的深度。
- **颜色调整**：在旋转过程中，适当地改变节点颜色，以维持红黑性质。

### 性能分析

红黑树通过平衡操作确保了最坏情况下仍保持 \(O(\log n)\) 的时间复杂度，使其在大规模数据处理中表现优异。与AVL树相比，红黑树在频繁的插入和删除操作中表现更为稳定，牺牲了一部分查找效率，以换取整体操作的高效性。


### 代码实现

```java
class RedBlackTree {
    private static final int RED = 0;
    private static final int BLACK = 1;

    private class Node {
        int data;
        int color;
        Node left, right, parent;

        Node(int data) {
            this.data = data;
            this.left = null;
            this.right = null;
            this.parent = null;
            this.color = RED;
        }
    }

    private Node root;
    private Node NIL;

    public RedBlackTree() {
        NIL = new Node(0);
        NIL.color = BLACK;
        NIL.left = null;
        NIL.right = null;
        root = NIL;
    }

    private void leftRotate(Node x) {
        Node y = x.right;
        x.right = y.left;
        if (y.left != NIL) {
            y.left.parent = x;
        }
        y.parent = x.parent;
        if (x.parent == null) {
            root = y;
        } else if (x == x.parent.left) {
            x.parent.left = y;
        } else {
            x.parent.right = y;
        }
        y.left = x;
        x.parent = y;
    }

    private void rightRotate(Node x) {
        Node y = x.left;
        x.left = y.right;
        if (y.right != NIL) {
            y.right.parent = x;
        }
        y.parent = x.parent;
        if (x.parent == null) {
            root = y;
        } else if (x == x.parent.right) {
            x.parent.right = y;
        } else {
            x.parent.left = y;
        }
        y.right = x;
        x.parent = y;
    }

    public void insert(int key) {
        Node node = new Node(key);
        node.parent = null;
        node.data = key;
        node.left = NIL;
        node.right = NIL;
        node.color = RED;

        Node y = null;
        Node x = this.root;

        while (x != NIL) {
            y = x;
            if (node.data < x.data) {
                x = x.left;
            } else {
                x = x.right;
            }
        }

        node.parent = y;
        if (y == null) {
            root = node;
        } else if (node.data < y.data) {
            y.left = node;
        } else {
            y.right = node;
        }

        if (node.parent == null) {
            node.color = BLACK;
            return;
        }

        if (node.parent.parent == null) {
            return;
        }

        fixInsert(node);
    }

    private void fixInsert(Node k) {
        Node u;
        while (k.parent.color == RED) {
            if (k.parent == k.parent.parent.right) {
                u = k.parent.parent.left;
                if (u.color == RED) {
                    u.color = BLACK;
                    k.parent.color = BLACK;
                    k.parent.parent.color = RED;
                    k = k.parent.parent;
                } else {
                    if (k == k.parent.left) {
                        k = k.parent;
                        rightRotate(k);
                    }
                    k.parent.color = BLACK;
                    k.parent.parent.color = RED;
                    leftRotate(k.parent.parent);
                }
            } else {
                u = k.parent.parent.right;
                if (u.color == RED) {
                    u.color = BLACK;
                    k.parent.color = BLACK;
                    k.parent.parent.color = RED;
                    k = k.parent.parent;
                } else {
                    if (k == k.parent.right) {
                        k = k.parent;
                        leftRotate(k);
                    }
                    k.parent.color = BLACK;
                    k.parent.parent.color = RED;
                    rightRotate(k.parent.parent);
                }
            }
            if (k == root) {
                break;
            }
        }
        root.color = BLACK;
    }

    public void printTree(Node node) {
        if (node == NIL) {
            return;
        }
        printTree(node.left);
        System.out.println(((node.color==RED)?"Color: Red ":"Color: Black ") + "Key: " + node.data);
        printTree(node.right);
    }

    public void printTree() {
        printTree(this.root);
    }
}

```