
## 前缀和及其变体

### 前缀和

#### 概念
前缀和是一种用于快速求解区间和问题的技术。给定一个数组 `arr`，前缀和的每个元素 `sum[i]` 代表从 `arr[0]` 到 `arr[i]` 的总和，可以表示为：

![image](https://github.com/baibairui/Data-Structure-and-Algorthim/assets/123094711/668907be-966d-4e49-9bf1-dc84561d3f9c)<br>
![image](https://github.com/baibairui/Data-Structure-and-Algorthim/assets/123094711/5a5f4082-d742-4a37-8dbd-aed413731ebd)<br>

这种方法可以快速计算任意区间的总和，通过下列公式：

![image](https://github.com/baibairui/Data-Structure-and-Algorthim/assets/123094711/f120f3ab-d92e-4242-9ce6-58d872a71210)


#### 用法
前缀和适用于多次查询数组某个固定区间的场景，能将区间和查询的时间复杂度降到 `O(1)`。

#### 实现
```java
public int[] buildPrefixSum(int[] arr) {
    int[] sum = new int[arr.length + 1];
    sum[0] = 0;
    for (int i = 1; i <= arr.length; i++) {
        sum[i] = sum[i - 1] + arr[i - 1];
    }
    return sum;
}

public int queryPrefixSum(int[] sum, int l, int r) {
    return sum[r + 1] - sum[l];
}
````

### 前缀积

#### 概念
前缀积是前缀和的一个变体，用于快速计算数组的乘积区间。对于数组 arr，前缀积 prod[i] 代表从 arr[0] 到 arr[i] 所有元素的乘积，可以表示为：

![image](https://github.com/baibairui/Data-Structure-and-Algorthim/assets/123094711/e9621e2e-722d-4cc2-ac64-2a24a3a9bcb1)<br>
![image](https://github.com/baibairui/Data-Structure-and-Algorthim/assets/123094711/26befc8e-758a-4857-9ea5-04d11faf6cf7)<br>

进而得到：

![image](https://github.com/baibairui/Data-Structure-and-Algorthim/assets/123094711/21c5e107-51d4-462e-a036-e7327cda3821)


#### 用法
与前缀和类似，前缀积可以快速计算数组区间乘积。

#### 实现
````java
public int[] buildPrefixProduct(int[] arr) {
    int[] prod = new int[arr.length + 1];
    prod[0] = 1;
    for (int i = 1; i <= arr.length; i++) {
        prod[i] = prod[i - 1] * arr[i - 1];
    }
    return prod;
}
````

### 异或前缀和

#### 概念
异或前缀和是用于快速计算数组异或区间的技术。对于数组 arr，异或前缀和 xsum[i] 代表从 arr[0] 到 arr[i] 所有元素的异或结果，可以表示为：

![image](https://github.com/baibairui/Data-Structure-and-Algorthim/assets/123094711/e0ce2fd3-d75b-4d73-8710-f9a9b134585f)<br>

![image](https://github.com/baibairui/Data-Structure-and-Algorthim/assets/123094711/703fe0b3-7a21-4b41-a6f3-c040326af808)<br>

进而得到：

![image](https://github.com/baibairui/Data-Structure-and-Algorthim/assets/123094711/0da8197f-07b1-4dfa-8323-a44434a69e52)<br>


#### 用法
利用异或运算的性质，可以快速求出任意区间内元素的异或总和

#### 实现
````java
public int[] buildXorPrefixSum(int[] arr) {
    int[] xsum = new int[arr.length + 1];
    xsum[0] = 0;
    for (int i = 1; i <= arr.length; i++) {
        xsum[i] = xsum[i - 1] ^ arr[i - 1];
    }
    return xsum;
}
````
### 二维前缀和
二维前缀和是一种用于处理二维数组（或矩阵）区域和查询的高效方法。<br>
与一维前缀和类似，它通过预计算一个辅助数组来加速区域和的查询，使得无论查询区域的大小如何，计算区域和的时间复杂度都能保持为常数级别（O(1)）。<br>

![image](https://github.com/baibairui/Data-Structure-and-Algorthim/assets/123094711/5e8a4a63-4597-4ed5-8b93-bf723c2872d0)<br>

![image](https://github.com/baibairui/Data-Structure-and-Algorthim/assets/123094711/0571cbfe-9340-489b-a318-e7a21bfcc99c)<br>


#### 实现
```` java
class NumMatrix {
    int[][]presum;

    public NumMatrix(int[][] matrix) {
    if(matrix.length == 0 || matrix[0].length == 0) return;
    int m = matrix.length;
    int n = matrix[0].length;
    presum = new int[m][n];
    for(int i = 0; i < m; i++) {
        for(int j = 0; j < n; j++) {
            int top = (i > 0) ? presum[i-1][j] : 0;
            int left = (j > 0) ? presum[i][j-1] : 0;
            int topLeft = (i > 0 && j > 0) ? presum[i-1][j-1] : 0;
            presum[i][j] = matrix[i][j] + top + left - topLeft;
        }
    }
}
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
    int total = presum[row2][col2];
    int top = (row1 > 0) ? presum[row1-1][col2] : 0;
    int left = (col1 > 0) ? presum[row2][col1-1] : 0;
    int topLeft = (row1 > 0 && col1 > 0) ? presum[row1-1][col1-1] : 0;
    return total - top - left + topLeft;
}
}

````


### 相关力扣题链接

**线性前缀和** <br>

[一维数组的动态和](https://leetcode.cn/problems/running-sum-of-1d-array/description/)<br>

[寻找数组的中心下标](https://leetcode.cn/problems/find-pivot-index/description/)<br>

[和可被K整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/)<br>

[找出中枢整数](https://leetcode.cn/problems/find-the-pivot-integer/description/)<br>

[寻找最高海拔](https://leetcode.cn/problems/find-the-highest-altitude/description/)<br>

[逐步求和得到正数的最小值](https://leetcode.cn/problems/minimum-value-to-get-positive-step-by-step-sum/description/)

[一维区域和检索](https://leetcode.cn/problems/range-sum-query-immutable/description/)<br>

**异或前缀和** <br>

[子数组异或查询](https://leetcode.cn/problems/xor-queries-of-a-subarray/description/)<br>

**二维前缀和** <br>

[二维区域和检索](https://leetcode.cn/problems/range-sum-query-2d-immutable/description/)<br>

[矩阵区域和](https://leetcode.cn/problems/matrix-block-sum/description/)<br>

[找出第K大的异或值](https://leetcode.cn/problems/find-kth-largest-xor-coordinate-value/description/)<br>
