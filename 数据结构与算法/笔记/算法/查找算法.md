# 查找算法

## **1. 顺序查找**

**意简言赅，一个个找，不要求数组有序**

### 复杂度证明
**递推关系式**
\[T(n)=T(n-1)+1\]
**当目标数不在数组中时**
\[ \begin{align*}T(n) &=T(n-1)+1\\
&=T(n-2)+1+1\\&=\cdots\\&=\underbrace{1+1+1+1+1+\cdots+1}_n\\&=n
\end{align*} \]
**最差情况下的时间复杂度**
\[T(n)=O(n)\]
**最好情况下的时间复杂度**
\[T(n)=O(1)\]
### 代码实现
```` java
public static int seqSearch(int[] arr,int target){
    for(int i=0;i<arr.length;i++){
        if(arr[i]==target){
            return i;
        }
        return -1;
    }
}
````
## **2. 二分查找**

**分治思想的体现，每次都把问题缩小为原问题的一半，要求数组有序**
### 复杂度证明
**有递归关系式**
\[T(n)=\begin{cases}T(\frac{n}{2})+1 &,n \ge 2\\
1 &,n=1\end{cases}\]
**如果目标数不在数组中,分治的子问题会递归到最终出口**
\[ \begin{align*}T(n)&=T(\frac{n}{2})+1\\&=T(\frac{n}{2^2})+1+1\\&=\cdots\\&=T(\frac{n}{2^k})+\underbrace{1+1+1+\cdots+1}_{k}\end{align*}\]
**当递归终止时**
\[\frac{n}{2^k}=1\to k= \log_{2}n\]

\[\begin{align*}T(n)&=\underbrace{1+1+1+1+\cdots+1}_{\log_{2}n +1}\\&=log_{2}n + 1\end{align*}\]

**最差的情况下的时间复杂度**
\[T(n)=O(logn)\]
**最优的情况下的时间复杂度**
\[T(n)=O(1)\]

### 代码实现
```` java
public static int binSearch(int[] arr,int target){
    int left=0;
    int right=arr.length-1;
    int mid=(left+((right-left)>>1));//利用位运算提高速度
    while(left<right){
        if(arr[mid]==target){
            return target;
        }
        if(arr[mid]<target){
            left=mid+1;
        }else{
            right=mid-1;
        }
        mid=(left+((right-left)>>1));
    }
    return -1;
}
````

## 3. 斐波那契搜索

**分治思想的体现，每次分割问题的比例都是黄金分割比，要求数组有序**

### 时间复杂度证明
**对于斐波那契数列**
\[Fib(n)=Fib(n-1)+Fib(n-2)\]
**斐波那契数列会收敛**
\[{当} n \to +\infin\]
\[\frac{Fib(n)}{Fib(n-1)}\approx 1.618\]
\[\frac{Fib(n)}{Fib(n-2)}\approx 2.618\]
**设每次都将母问题规模缩小到原来的1/k倍**
\[k=\begin{cases}\frac{Fib(n)}{Fib(n-1)} &,arr[i]<target\\ \\\frac{Fib(n)}{Fib(n-2)} &,arr[i]>target \end{cases}\]

**

### 代码实现