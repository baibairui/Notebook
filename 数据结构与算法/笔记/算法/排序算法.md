## 排序算法

### 冒泡排序
- **基本思想**：重复遍历待排序序列，比较相邻两个元素，如果它们的顺序错误就把它们交换过来。过程重复直到不需要再交换，即序列完全有序。
- **时间复杂度**：平均和最坏情况下都是 O(n^2)，最好情况是 O(n)。
- **空间复杂度**：O(1)。
- **稳定性**：稳定。
- **代码实现**
```` cpp
void sort::bubbleSort(vector<int>&arr){
    for(int i=0;i<arr.size();i++){
        for(int j=0;j<arr.size()-i-1;j++){
            if(arr[j]>arr[j+1]){
                std::swap(arr[j],arr[j+1]);
            }
        }
    }
}
````
### 选择排序
- **基本思想**：首先在未排序序列中找到最小（大）元素，放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素排序完毕。
- **时间复杂度**：平均和最坏情况下都是 O(n^2)。
- **空间复杂度**：O(1)。
- **稳定性**：不稳定。
- **代码实现**
```` cpp
void sort::selectionSort(vector<int>&arr){
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i; // 初始化当前最小值的索引为i
        for (int j = i + 1; j < n; j++) {
            // 查找最小值的索引
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        // 交换当前位置i和最小值位置minIdx的元素
        std::swap(arr[i], arr[minIdx]);
    }
}
````
### 插入排序
- **基本思想**：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
- **时间复杂度**：平均和最坏情况下是 O(n^2)，最好情况是 O(n)。
- **空间复杂度**：O(1)。
- **稳定性**：稳定。
- **代码实现**
```` java

````
### 快速排序
- **基本思想**：选择一个“基准”元素，分区过程将数组分为两个部分，使得一部分的元素都比基准小，另一部分的元素都比基准大，然后递归地对这两部分继续进行快速排序。
- **时间复杂度**：平均情况下是 O(n log n)，最坏情况下是 O(n^2)。
- **空间复杂度**：平均是 O(log n)。
- **稳定性**：不稳定。
- **代码实现**
```` java

````
### 归并排序
- **基本思想**：将已有序的子序列合并，得到完全有序的序列；即先分解序列为子序列，使每个子序列有序，然后再合并子序列。
- **时间复杂度**：平均和最坏情况下都是 O(n log n)。
- **空间复杂度**：O(n)，需要额外的空间来合并序列。
- **稳定性**：稳定。
- **代码实现**
```` java
public void mergesort(int[] arr,int left,int right){
    if(left>right)return;
    int mid=left+((right-left)>>1);
    mergesort(arr,left,mid-1);
    mergesort(arr,mid+1,right);
    merge(arr,left,right,mid);
}
public void merge(int [] arr,int left,int right,int mid){
    int[] tmp=new int[right-left+1];
    int i=left,j=mid,k=0;
    while(i<=mid&&j<=right){
        if(arr[i]<arr[j]){
            tmp[k++]=arr[i++];
        }else{
            tmp[k++]=arr[j++];
        }
    }
    while(i<=mid)tmp[k++]=arr[i++];
    while(j<=right)tmp[k++]=arr[j++];
}
````
### 基数排序
- **基本思想**：按照低位先排序，然后收集；再按照高位排序，然后再收集；以此类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。
- **时间复杂度**：O(nk)，其中 n 是排序元素个数，k 是数字位数。
- **空间复杂度**：O(n+k)，需要额外的空间来存放临时排序的结果。
- **稳定性**：稳定。
- **代码实现**
```` java

````
### 相关习题


