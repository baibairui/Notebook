# 算法复杂度

---
## 一. 常用符号

### 1. O(n)

**大O符号用于表示算法的最坏情况复杂度。** 它描述了算法在输入规模无限增大时所需的最大运算次数。

**定义**

如果存在正整数 \(c\) 和 \(N\)，对于所有的 \(n \geq N\)，有 \(f(n) \leq c \cdot g(n)\)，则 \(f(n) = O(g(n))\)。

#### 示例

```java
// 线性搜索的时间复杂度为 O(n)
int linearSearch(int[] arr, int key) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == key) {
            return i;
        }
    }
    return -1;
}
```

### 2. Ω(n) -Omega符号

**Omega符号用于表示算法的最佳情况复杂度。** 它描述了算法在输入规模无限增大时所需的最小运算次数。

#### 定义
如果存在正整数 \(c\) 和 \(N\)，对于所有的 \(n \geq N\)，有 \(f(n) \geq c \cdot g(n)\)，则表示 \(f(n) = \Omega(g(n))\)。

#### 示例
```java
// 假设数组已排序，则二分查找的时间复杂度为 Ω(log n)
int binarySearch(int[] arr, int key) {
    int low = 0;
    int high = arr.length - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (arr[mid] < key) {
            low = mid + 1;
        } else if (arr[mid] > key) {
            high = mid - 1;
        } else {
            return mid;  // 找到key
        }
    }
    return -1;  // 未找到key
}
```

### 3. Θ(n) - Theta符号

**Theta符号用于表示算法的平均或期望复杂度。** 它描述了算法复杂度的上下界都符合同一个函数。

#### 定义
如果存在正整数 \(c_1\), \(c_2\) 和 \(N\)，对于所有的 \(n \geq N\)，有 \(c_2 \cdot g(n) \geq f(n) \geq c_1 \cdot g(n)\)，则表示 \(f(n) = \Theta(g(n))\)。

#### 示例
```java
// 插入排序的时间复杂度在最佳情况下为 Ω(n)，最坏情况下为 O(n^2)，平均情况下为 Θ(n^2)
int[] insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
    return arr;
}
```

---

## 二. 常用数学符号与近似函数


### 常见数学符号

| 符号 | 名称     | 符号表示  | 定义                   | 用途                |
|------|----------|-----------|------------------------|--------------------|
| ⌊x⌋  | 下取整   | \[⌊x⌋\] | 最大的不大于 x 的整数  | 取整操作            |
| ⌈x⌉  | 上取整   | \[⌈x⌉\] | 最小的不小于 x 的整数  | 取整操作            |
| lnN  | 自然对数 | \[lnN\]   | 对数以 e 为底          | 数学计算            |
| \[2^{lgN}\] | 幂与对数的关系 | \[2^{lg N}\] | \(N\)（当底为 2 时） | 计算机科学中常用    |
| ⌊lgN⌋ | 对数的下取整 | \[\lfloor \lg N \rfloor\] | 不大于 \(\lg N\) 的最大整数 | 位运算中的位数计算  |
| \[H_N\] | 调和级数 | \[H_N\]     | \(\sum_{i=1}^{N} \frac{1}{i}\) | 分析算法中的级数和  |
| N!  | 阶乘     | \[N!\]      | \(1 \times 2 \times 3 \times \ldots \times N\) | 组合数学中的计算    |

### 算法分析中常用的近似表示

| 近似名称     | 表达式                 | 定义                                    | 应用场景          |
|--------------|------------------------|-----------------------------------------|------------------|
| 调和级数近似 | \(H_N \approx \ln N\) | \(\sum_{i=1}^{N} \frac{1}{i} \approx \ln N\) | 算法时间复杂度分析 |
| 等差级数近似 | \(1+2+3+\ldots+N \approx \frac{N^2}{2}\) | \(\sum_{i=1}^{N} i = \frac{N(N+1)}{2} \approx \frac{N^2}{2}\) | 数列求和          |
| 等比级数近似 | \(1+2+4+\ldots+2^{N-1} \approx 2^N\) | \(\sum_{i=0}^{N-1} 2^i = 2^N - 1 \approx 2^N\) | 运算过程分析      |
| 对数级数近似 | \(\ln N! \approx \sum_{i=1}^{N} \ln i\) | 斯特灵近似：\(\ln N! \approx N \ln N - N\) | 排列组合问题      |
| 二项式系数   | \(\binom{N}{k} \approx \frac{N^k}{k!}\) | 斯特灵近似的应用                          | 组合数计算        |
| 指数级数     | \(e^x \approx \frac{1}{(1-x)}\) for small \(x\) | 泰勒级数的应用                            | 近似计算          |

---
## 三. 时间复杂度与空间复杂度

### 时间复杂度 (Time Complexity)

时间复杂度是衡量一个算法执行所需时间的指标。它描述了算法执行时间随输入数据的大小增加而增加的速率。时间复杂度通常用大O符号表示，例如 `O(n)`, `O(log n)`, `O(n^2)` 等。

#### 常见的时间复杂度级别

- **常数时间 `O(1)`**：执行时间不依赖于输入数据的大小。
- **对数时间 `O(log n)`**：例如二分查找，时间复杂度与输入数据的对数成正比。
- **线性时间 `O(n)`**：例如数组遍历，时间复杂度与输入数据大小成正比。
- **线性对数时间 `O(n log n)`**：例如快速排序和归并排序。
- **二次时间 `O(n^2)`**：例如冒泡排序，执行时间随输入数据的平方增长。
- **立方时间 `O(n^3)`**：常见于涉及三层嵌套循环的算法。
- **指数时间 `O(2^n)`**：例如许多递归算法，执行时间随输入数据的指数增长。

### 空间复杂度 (Space Complexity)

空间复杂度是衡量一个算法在执行过程中所需的存储空间量。它帮助我们了解算法对存储资源的消耗。

#### 常见的空间复杂度级别

- **常数空间 `O(1)`**：如使用固定数量和大小的变量。
- **线性空间 `O(n)`**：如动态分配的数组。
- **二次空间 `O(n^2)`**：在处理矩阵或二维数组的算法中常见。

### 时间与空间复杂度的权衡

在实际应用中，通常需要在时间复杂度和空间复杂度之间进行权衡。有时，为了加快算法的执行速度，我们可能需要牺牲更多的存储空间（例如，通过使用缓存）。理解这种权衡对于设计高效且实用的算法至关重要。

---

## 四. 非递归算法的复杂度计算

 - [X] [概率分析](./概率分析.md)
 - [X] [均摊分析](./均摊分析.md)



## 五. 递归算法的复杂度计算

- [X] [迭代法](./迭代法.md)
- [X] [替代法](./替代法.md)
- [X] [主定理法](./主定理法.md)
- [X] [递归树法](./递归树.md)